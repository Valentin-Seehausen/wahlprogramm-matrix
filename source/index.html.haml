- dist = data.distances
- agendas = data.agendas
- all_docs = agendas.map(&:last).reduce(:+)
- min = 0.1
- OUTLIER = 0.05
- is_outlier = lambda { |doc| (data.outlier[doc.id] || 1) < OUTLIER }
- score_classes_fn = lambda { |p| all_docs.map { |doc| [doc, dist[p.id][doc.id]] }.select { |(doc, d)| d.is_a?(Numeric) && d > min }.map { |(doc, d)| [doc, ((1.0-d)/(1.0-min)*10).round] }.map { |(doc, d)| "dist-#{doc.id.gsub('.','')}-#{d}" } }
- sass_doc_list = all_docs.map(&:id).map { |id| id.gsub('.','') }.map(&:inspect).join(', ')

:sass
  $docs: #{sass_doc_list}
  $distLevels: 10
  @each $doc in $docs
    .doc-\#{$doc}-selected
      @for $level from 0 to $distLevels
        .doc.dist-\#{$doc}-\#{$level}
          background-color: rgba(255, 0, 0, (1-$level/$distLevels)/2)
        a.dist-\#{$doc}-\#{$level}
          background-color: rgba(255, 0, 0, 1-$level/$distLevels)

%header#help
  #close ✗
  #questionmark ?
  #help-content
    %h1
      %a{href:'http://codeformuenster.org'}
        %img{src:'http://codeformuenster.org/img/cfm_logo.png', alt:'Code for Münster'}
      Wahlprogramm-Matrix
    %p#description
      Mit dieser App kannst du die
      %em Wahlprogramme der Kommunalwahl 2014 in Münster
      mit etwas technischer Unterstützung lesen.
    %h2 Wie benutze ich die App?
    %ul#manual-text
      %li
        Klicke auf einen Paragraphen um ihn auszuwählen. Der ausgewählte Paragraph und weitere thematisch ähnliche werden
        %span.highlight-similar farblich
        hervorgehoben.
      %li
        Die Scroll-Leisten zeigen durch
        %span.highlight-similar farbliche
        Hinterlegung an, wo im zugehörigen Wahlprogramm die thematisch ähnlichen Paragraphen zu finden sind. Klicke auf die Leiste um zum Paragraphen zu springen.
      %li Führe die Maus über die Scroll-Leiste um für die Paragraphen relevante Begriffe zu sehen.
      %li
        Außenseiter sind
        %span.highlight-outlier blau
        hervorhehoben. Diese Paragraphen haben zu allen anderen Paragraphen einen hohen semantischen Abstand.

    %p#manual-movie
      = image_tag 'manual.gif'
    %h2 Wie funktioniert das?
    %p#tech
      Die Ähnlichkeit wird rein maschinell ermittelt. Dazu werden die Wörter in den einzelnen Paragraphen miteinander verglichen und so ein semantischer Abstand errechnet. Welche Wörter der Algorithmus dabei als besonders relevant empfindet, kann man sehen, wenn man mit dem Mauszeiger über die Scroll-Leisten schwebt. Dabei kommen oft sinnvolle aber manchmal auch nicht so sinnvolle Ergebnisse heraus.
    %h2 Warum tut ihr sowas?
    %p#rationale
      Dies ist als Experiment zu verstehen. Wir wollen herausfinden, wie sich Algorithmen nutzen lassen, um Menschen zu helfen politische Prozesse zu verstehen.
    #attribution
      %p Dies ist ein Experiment von <a href="http://kirelabs.org">Daniel Kirsch</a>, <a href="https://github.com/djmaze">Martin Honermeyer</a>, <a href="https://github.com/webwurst">Tobias Bradtke</a> und <a href="https://github.com/jahnique">Yannic Schencking</a>

#container
  #spd-minimap.minimap
    .scroll-indicator
    - agendas.SPD.each do |p|
      - classes = score_classes_fn[p]
      - classes << 'outlier' if is_outlier[p]
      %a{href: "#doc-#{p.id.gsub('.','')}", style: "height: #{100.0*p.text.length/agendas.SPD.map(&:text).map(&:length).reduce(:+)}%", class: classes, :"data-important" => data.important[p.id].join(', ')}
  #spd.sub-container
    .wrapper
      %h1.party-name SPD
      - agendas.SPD.each do |p|
        - classes = score_classes_fn[p]
        - classes << 'outlier' if is_outlier[p]
        .doc{id: "doc-#{p.id.gsub('.','')}", class: classes, data: {click: "doc-#{p.id.gsub('.','')}-selected"}}
          = GitHub::Markdown.render p.text
  #cdu-minimap.minimap
    .scroll-indicator
    - agendas.CDU.each do |p|
      - classes = score_classes_fn[p]
      - classes << 'outlier' if is_outlier[p]
      %a{href: "#doc-#{p.id.gsub('.','')}", style: "height: #{100.0*p.text.length/agendas.CDU.map(&:text).map(&:length).reduce(:+)}%", class: classes, :"data-important" => data.important[p.id].join(', ')}
  #cdu.sub-container
    .wrapper
      %h1.party-name CDU
      - agendas.CDU.each do |p|
        - classes = score_classes_fn[p]
        - classes << 'outlier' if is_outlier[p]
        .doc{id: "doc-#{p.id.gsub('.','')}", class: classes, data: {click: "doc-#{p.id.gsub('.','')}-selected"}}
          = GitHub::Markdown.render p.text
  #gruene-minimap.minimap
    .scroll-indicator
    - agendas.Gruene.each do |p|
      - classes = score_classes_fn[p]
      - classes << 'outlier' if is_outlier[p]
      %a{href: "#doc-#{p.id.gsub('.','')}", style: "height: #{100.0*p.text.length/agendas.Gruene.map(&:text).map(&:length).reduce(:+)}%", class: classes, :"data-important" => data.important[p.id].join(', ')}
  #gruene.sub-container
    .wrapper
      %h1.party-name Grüne
      - agendas.Gruene.each do |p|
        - classes = score_classes_fn[p]
        - classes << 'outlier' if is_outlier[p]
        .doc{id: "doc-#{p.id.gsub('.','')}", class: ["dist-#{p.id.gsub('.','')}-0"] + classes, data: {click: "doc-#{p.id.gsub('.','')}-selected"}}
          = GitHub::Markdown.render p.text
  #piraten-minimap.minimap
    .scroll-indicator
    - agendas.Piraten.each do |p|
      - classes = score_classes_fn[p]
      - classes << 'outlier' if is_outlier[p]
      %a{href: "#doc-#{p.id.gsub('.','')}", style: "height: #{100.0*p.text.length/agendas.Piraten.map(&:text).map(&:length).reduce(:+)}%", class: classes, :"data-important" => data.important[p.id].join(', ')}
  #piraten.sub-container
    .wrapper
      %h1.party-name Piraten
      - agendas.Piraten.each do |p|
        - classes = score_classes_fn[p]
        - classes << 'outlier' if is_outlier[p]
        .doc{id: "doc-#{p.id.gsub('.','')}", class: ["dist-#{p.id.gsub('.','')}-0"] + classes, data: {click: "doc-#{p.id.gsub('.','')}-selected"}}
          = GitHub::Markdown.render p.text
